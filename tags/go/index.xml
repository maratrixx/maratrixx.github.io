<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on MARATRIX BLOG</title>
    <link>https://maratrix.cn/tags/go/</link>
    <description>Recent content in go on MARATRIX BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 10 Jan 2022 09:13:21 +0800</lastBuildDate><atom:link href="https://maratrix.cn/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Kratos 源码分析（一）|日志组件设计与实现</title>
      <link>https://maratrix.cn/post/2022/01/10/kratos-logger-design/</link>
      <pubDate>Mon, 10 Jan 2022 09:13:21 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2022/01/10/kratos-logger-design/</guid>
      <description>本文基于 kratos v2.1.3 设计理念 为了方便使用，Kratos 定义了两个层面的抽象，Logger 统一了日志的接入方式，Helper 接口统一的日志库的调用方式。 在不同的公司、使用不同的基础架构，可能对日志的打印方式、格</description>
    </item>
    
    <item>
      <title>如何获取Go服务依赖包</title>
      <link>https://maratrix.cn/post/2021/04/28/go-deps/</link>
      <pubDate>Wed, 28 Apr 2021 18:38:26 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/04/28/go-deps/</guid>
      <description>在服务治理中，我们有时需要统计业务方服务的依赖包版本号使用情况，以便进行升级和版本兼容，通过 Go 官方提供的 debug.ReadBuildInfo 可以很方便的实现。 debug.ReadBuildInfo ReadBuildInfo 是 Go 标准库提供的方法，通过该方法可以读取打包程序的构建信息，里面就包括我</description>
    </item>
    
    <item>
      <title>Go1.16新特性|标准库和其他变化</title>
      <link>https://maratrix.cn/post/2021/03/10/go1.16-core-library-changes/</link>
      <pubDate>Wed, 10 Mar 2021 08:58:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/03/10/go1.16-core-library-changes/</guid>
      <description>支持静态资源嵌入 参见之前的文章：Go1.16新特性|embed静态资源嵌入 新增 io/fs 的支持 Go 1.16 标准库新增 io/fs 包，并定义了一个 fs.File 接口用于表示一个只读文件树 (tree of file) 的抽象。 io/fs 包的两个最重要的接口如下： 1 2 3 4 5 6</description>
    </item>
    
    <item>
      <title>Go1.16新特性|Module功能新变化</title>
      <link>https://maratrix.cn/post/2021/03/10/go1.16-module/</link>
      <pubDate>Wed, 10 Mar 2021 08:06:49 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/03/10/go1.16-module/</guid>
      <description>Module 功能默认开启 在 Go 1.16 版本中，Go module-aware 模式成为了默认模式 (另一种则是传统的 gopath 模式)。module-aware 模式成为默认意味着什么呢？意味着 GO111MODULE 的值默认为 on 了。 这里将 Go 1.13 版本之前、Go 1.13 版本以及 Go 1.16 版本在 GO111MODULE</description>
    </item>
    
    <item>
      <title>Go1.16新特性|embed静态资源嵌入[转]</title>
      <link>https://maratrix.cn/post/2021/02/21/go-embed-syntax/</link>
      <pubDate>Sun, 21 Feb 2021 09:23:28 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/02/21/go-embed-syntax/</guid>
      <description>本文转自：https://colobu.com/2021/01/17/go-embed-tutorial/，并稍作修改。 Go 编译的程序非常适合部署，如果没有通过 CGO 引用其它的库的话，我们一般编译出来的可执</description>
    </item>
    
    <item>
      <title>[转]Go语言如何使用条件编译</title>
      <link>https://maratrix.cn/post/2020/12/17/go-cond-build/</link>
      <pubDate>Thu, 17 Dec 2020 23:00:41 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/12/17/go-cond-build/</guid>
      <description>当开发需要依赖底层平台或处理器体系特性的Go包时，提供对应的特定实现是非常有必要的。 Go没有预处理，没有宏定义系统，不可以像c语言那样使用#define来控制是否包含平台相关的特定代码。作为替代，Go</description>
    </item>
    
    <item>
      <title>Go源码阅读 | channel 设计与实现</title>
      <link>https://maratrix.cn/post/2020/08/25/go-channel-source-read/</link>
      <pubDate>Tue, 25 Aug 2020 22:40:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/08/25/go-channel-source-read/</guid>
      <description>本文基于 Go1.14 源码阅读 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91</description>
    </item>
    
    <item>
      <title>Go源码阅读 | context.Context设计与实现</title>
      <link>https://maratrix.cn/post/2020/07/12/go-context-source-read/</link>
      <pubDate>Sun, 12 Jul 2020 16:55:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/07/12/go-context-source-read/</guid>
      <description>本文基于 Go1.14.2 Go 自带的 context 包设计的很巧妙，最近阅读了下源码实现，可谓是短小精悍，很值得投入时间去学习。 什么是 context Go1.7 开始引入的 context 标准库包，主要用来在协程之间传递上下文信息，包括：取消信号、超时控制、截止时间、k</description>
    </item>
    
    <item>
      <title>如何借助Go指令生成随机数</title>
      <link>https://maratrix.cn/post/2020/06/14/go-fast-random/</link>
      <pubDate>Sun, 14 Jun 2020 18:36:57 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/06/14/go-fast-random/</guid>
      <description>如何在 Go 开发中高效而又快速地生成随机数呢？相信大家首先想到的就是使用标准库自带的 math/rand 包，或者使用开源的第三方包（比如 github.com/valyala/fastrand）来实现。 Go 运行时自带了 runtime.fastrand 函数来</description>
    </item>
    
    <item>
      <title>[转]简单围观一下有趣的//go:指令</title>
      <link>https://maratrix.cn/post/2020/06/13/go-directive-syntax/</link>
      <pubDate>Sat, 13 Jun 2020 09:11:02 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/06/13/go-directive-syntax/</guid>
      <description>前言 如果你平时有翻看源码的习惯，你肯定会发现。咦，怎么有的方法上面总是写着 //go: 这类指令呢。他们到底是干嘛用的？ 今天我们一同揭开他们的面纱，我将简单给你介绍一下，它们都负责些什么。 go:linkname 1 //go:linkname localname importpath.name 该指令指示编译</description>
    </item>
    
    <item>
      <title>Go源码阅读 | sync.WaitGroup设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/25/go-sync-waitgroup-notes/</link>
      <pubDate>Sat, 25 Apr 2020 20:50:34 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/25/go-sync-waitgroup-notes/</guid>
      <description>前言 当我们的程序在运行过程中需要执行多个子任务时，我们可以利用 Go 协程并发地执行这些子任务，然后等待它们执行结束，从而缩短程序串行执行的耗费时间。Go 语言标准库自带了该组件：sync.WaitGroup</description>
    </item>
    
    <item>
      <title>Go源码阅读 | sync.Once设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/21/go-sync-once-source-notes/</link>
      <pubDate>Tue, 21 Apr 2020 11:55:18 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/21/go-sync-once-source-notes/</guid>
      <description>介绍 sync.Once 是 Go 官方自带的标准库，实现了 exactly once 的功能。通过使用 sync.Once 我们可以很方便地实现单例模式，确保对象只被初始化一次。 首先看一个 sync.Once 的 Go 官方例子，源码链接在这里： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var once sync.Once onceBody := func() { fmt.Println(&amp;#34;Only once&amp;#34;) }</description>
    </item>
    
    <item>
      <title>Go中如何实现禁止拷贝</title>
      <link>https://maratrix.cn/post/2020/04/20/go-nocopy-notes/</link>
      <pubDate>Mon, 20 Apr 2020 21:56:22 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/20/go-nocopy-notes/</guid>
      <description>背景 最近看 Go 标准库源码时经常遇到禁止拷贝对象的使用场景，比如当我们使用 strings.Builder 或者 sync.Pool 对象的时候会被禁止拷贝，这是如何实现的呢？ 主要有以下两种方式： 方式一：手动检查 这种需要我们在运行时通过 copyCheck 方法来检查是否发生</description>
    </item>
    
    <item>
      <title>Go源码阅读 | strings.Builder设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/14/strings-builder-source-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:55:41 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/14/strings-builder-source-note/</guid>
      <description>背景之字符串拼接 在 Go 语言中，对于字符串的拼接处理有很多种方法，那么那种方法才是效率最高的呢？ 1 2 3 4 5 6 str := []string{&amp;#34;aa&amp;#34;, &amp;#34;bb&amp;#34;, &amp;#34;cc&amp;#34;} ss := &amp;#34;&amp;#34; for _, s := range str { ss += s } fmt.Println(ss) 相信大部分人都会使用+操作符或者fmt.Sprinf进行</description>
    </item>
    
    <item>
      <title>Go Hijack黑科技</title>
      <link>https://maratrix.cn/post/2020/04/14/go-hijack-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:53:21 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/14/go-hijack-note/</guid>
      <description>最近在看Go标准库里面的rpc源码，发现了下面一段代码： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // ServeHTTP implements an http.Handler that answers RPC requests. func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) { if req.Method != &amp;#34;CONNECT&amp;#34; { w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;text/plain; charset=utf-8&amp;#34;) w.WriteHeader(http.StatusMethodNotAllowed) io.WriteString(w, &amp;#34;405 must CONNECT\n&amp;#34;) return } conn, _, err := w.(http.Hijacker).Hijack() //注意看这里 if err != nil { log.Print(&amp;#34;rpc hijacking &amp;#34;, req.RemoteAddr, &amp;#34;: &amp;#34;, err.Error())</description>
    </item>
    
    <item>
      <title>Nginx基于权重的轮询算法实现</title>
      <link>https://maratrix.cn/post/2020/04/14/smooth-weighted-round-robin/</link>
      <pubDate>Tue, 14 Apr 2020 11:47:28 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/14/smooth-weighted-round-robin/</guid>
      <description>Nginx平滑的基于权重轮询算法描述为： Algorithm is as follows: on each peer selection we increase current_weight of each eligible peer by its weight, select peer with greatest current_weight and reduce its current_weight by total number of weight points distributed among peers. 算法执行2步，选择出1个当前节点： 每个节点，用它们的当前值加上它们自己的权重。 选择当前值</description>
    </item>
    
    <item>
      <title>Go踩坑系列 | 为什么request.URL.Scheme取不到值</title>
      <link>https://maratrix.cn/post/2019/09/28/go-url-scheme-notes/</link>
      <pubDate>Sat, 28 Sep 2019 10:18:10 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/09/28/go-url-scheme-notes/</guid>
      <description>遇到的问题 最近在阅读echo框架的源码，发现context.go文件在读取请求的scheme时是单独封装了个方法。就很奇怪，go语言标准库不是自带了方法吗，干嘛不用？ 于是写了段代码来验证： 1 2 3 4 5 6</description>
    </item>
    
    <item>
      <title>Go踩坑系列 | json标准库string标签你用对了么</title>
      <link>https://maratrix.cn/post/2019/09/05/go-json-string-tag-notes/</link>
      <pubDate>Thu, 05 Sep 2019 10:15:11 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/09/05/go-json-string-tag-notes/</guid>
      <description>工作中，我们会经常用到Go自带的json标准库，使用也很简单，具体用法这里不多说。 有的时候上游传过来的字段是string类型的，但是我们却想用变成int来使用。 本来用一个json:&amp;quot;,str</description>
    </item>
    
    <item>
      <title>Go服务平滑重启实践</title>
      <link>https://maratrix.cn/post/2019/07/31/go-overseer-notes/</link>
      <pubDate>Wed, 31 Jul 2019 10:12:16 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/07/31/go-overseer-notes/</guid>
      <description>为了实现Golang业务的平滑重载，研究了一下github上比较成熟的解决方案，找到如下三个库： grace endless overseer 大致看了一下源码，grace和endless是比较像的，实现步骤如下： 监听信号 收到信号时fork子</description>
    </item>
    
    <item>
      <title>go:linkname用法</title>
      <link>https://maratrix.cn/post/2019/07/12/go-linkname-syntax-notes/</link>
      <pubDate>Fri, 12 Jul 2019 10:10:42 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/07/12/go-linkname-syntax-notes/</guid>
      <description>什么是go:linkname 这里引用Go官方文档的解释： //go:linkname localname importpath.name The //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. Because this directive can subvert the type system and package modularity, it is only enabled in</description>
    </item>
    
  </channel>
</rss>
