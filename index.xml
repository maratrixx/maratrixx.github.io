<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>MARATRIX BLOG</title>
    <link>https://maratrix.cn/</link>
    <description>Recent content on MARATRIX BLOG</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sat, 15 May 2021 10:51:27 +0800</lastBuildDate><atom:link href="https://maratrix.cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[转]如何选择开源协议</title>
      <link>https://maratrix.cn/post/2021/05/15/how-to-choose-free-software-licenses/</link>
      <pubDate>Sat, 15 May 2021 10:51:27 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/05/15/how-to-choose-free-software-licenses/</guid>
      <description>如何为代码选择开源许可证，这是一个问题。 世界上的开源许可证，大概有上百种。很少有人搞得清楚它们的区别。即使在最流行的六种 &amp;mdash;- GPL、BSD、MIT、Mozilla、Apache 和 LGPL&amp;mdash;- 之中做选择，也很复杂。</description>
    </item>
    
    <item>
      <title>如何获取Go服务依赖包</title>
      <link>https://maratrix.cn/post/2021/04/28/go-deps/</link>
      <pubDate>Wed, 28 Apr 2021 18:38:26 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/04/28/go-deps/</guid>
      <description>在服务治理中，我们有时需要统计业务方服务的依赖包版本号使用情况，以便进行升级和版本兼容，通过 Go 官方提供的 debug.ReadBuildInfo 可以很方便的实现。 debug.ReadBuildInfo ReadBuildInfo 是 Go 标准库提供的方法，通过该方法可以读取打包程序的构建信息，里面就包括我</description>
    </item>
    
    <item>
      <title>[转]跟我一起写 Makefile</title>
      <link>https://maratrix.cn/post/2021/04/09/gnu-makefile/</link>
      <pubDate>Fri, 09 Apr 2021 09:17:14 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/04/09/gnu-makefile/</guid>
      <description>本篇文章为转载，支持原创，请移步陈浩大神博客跟我一起写 Makefile。</description>
    </item>
    
    <item>
      <title>Prometheus学习笔记|03.四大度量指标了解与应用</title>
      <link>https://maratrix.cn/post/2021/03/17/go-metrics/</link>
      <pubDate>Wed, 17 Mar 2021 09:00:40 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/03/17/go-metrics/</guid>
      <description>什么是度量指标 度量是指对于一个物体或是事件的某个性质给予一个数字，使其可以和其他物体或是事件的相同性质比较。度量可以是对一物理量（如长度、尺寸或容量等）的估计或测定，也可以是其他较抽象的特质。 简单来讲</description>
    </item>
    
    <item>
      <title>Go1.16新特性|标准库和其他变化</title>
      <link>https://maratrix.cn/post/2021/03/10/go1.16-core-library-changes/</link>
      <pubDate>Wed, 10 Mar 2021 08:58:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/03/10/go1.16-core-library-changes/</guid>
      <description>支持静态资源嵌入 参见之前的文章：Go1.16新特性|embed静态资源嵌入 新增 io/fs 的支持 Go 1.16 标准库新增 io/fs 包，并定义了一个 fs.File 接口用于表示一个只读文件树 (tree of file) 的抽象。 io/fs 包的两个最重要的接口如下： 1// $GOROOT/src/io/fs/fs.go 2 3// An FS</description>
    </item>
    
    <item>
      <title>Go1.16新特性|Module功能新变化</title>
      <link>https://maratrix.cn/post/2021/03/10/go1.16-module/</link>
      <pubDate>Wed, 10 Mar 2021 08:06:49 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/03/10/go1.16-module/</guid>
      <description>Module 功能默认开启 在 Go 1.16 版本中，Go module-aware 模式成为了默认模式 (另一种则是传统的 gopath 模式)。module-aware 模式成为默认意味着什么呢？意味着 GO111MODULE 的值默认为 on 了。 这里将 Go 1.13 版本之前、Go 1.13 版本以及 Go 1.16 版本在 GO111MODULE</description>
    </item>
    
    <item>
      <title>Go1.16新特性|embed静态资源嵌入[转]</title>
      <link>https://maratrix.cn/post/2021/02/21/go-embed-syntax/</link>
      <pubDate>Sun, 21 Feb 2021 09:23:28 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/02/21/go-embed-syntax/</guid>
      <description>本文转自：https://colobu.com/2021/01/17/go-embed-tutorial/，并稍作修改。 Go 编译的程序非常适合部署，如果没有通过 CGO 引用其它的库的话，我们一般编译出来的可执</description>
    </item>
    
    <item>
      <title>Prometheus学习笔记|02.监控数据可视化</title>
      <link>https://maratrix.cn/post/2021/02/11/grafana-quick-start/</link>
      <pubDate>Thu, 11 Feb 2021 11:20:18 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/02/11/grafana-quick-start/</guid>
      <description>Prometheus UI 提供了快速验证 PromQL 以及临时可视化支持的能力，但其可视化能力却比较弱。一般情况下，我们都用 Grafana 来实现对 Prometheus 的可视化实现。 什么是Grafana Grafana 是一个开源的可视化平台，并且提供了对 Prometheus 的完整支持。 Grafana has become the wo</description>
    </item>
    
    <item>
      <title>Prometheus学习笔记|01.安装与快速入门</title>
      <link>https://maratrix.cn/post/2021/02/10/prometheus-expoter-install/</link>
      <pubDate>Wed, 10 Feb 2021 11:20:18 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/02/10/prometheus-expoter-install/</guid>
      <description>为了能够更加直观的了解 Prometheus Server，接下来我们将在本地部署并运行一个 Prometheus Server 实例，通过 Node Exporter 采集当前主机的系统资源使用情况。 本文基于 MacOS Go1.15.8 安装 Prometheus Server Prometheus 基于 Golang 编写、编译后的软件包，不依赖于任何的第三方依赖。用户</description>
    </item>
    
    <item>
      <title>Prometheus学习笔记|00.简介与原理</title>
      <link>https://maratrix.cn/post/2021/02/08/prometheus-intro/</link>
      <pubDate>Mon, 08 Feb 2021 11:20:18 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/02/08/prometheus-intro/</guid>
      <description>第一次接触并使用 Prometheus 是在上家公司（QTT）做一个商城项目，当然只是简单的使用并未过多的深入了解、学习。到现在，Prometheus 已经是服务监控领域的标配了，是时候深入好好研究总结一下它了。 服务治理有一</description>
    </item>
    
    <item>
      <title>hystrix-go 之流量控制实现</title>
      <link>https://maratrix.cn/post/2021/01/28/hystrix-go-flow-contorl-read/</link>
      <pubDate>Thu, 28 Jan 2021 09:23:28 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/01/28/hystrix-go-flow-contorl-read/</guid>
      <description>在分析 hystrix-go 主流程中，我们知道只有当获取令牌成功后才能继续往下正常执行用户自定义的闭包函数，否则还是会进行降级处理。 1cmd.ticket = &amp;lt;-circuit.executorPool.Tickets: // 获取令牌成功 今天我们分析下，hystrix-go 是如何进行流量控制的。 源码分析 hystrix-go</description>
    </item>
    
    <item>
      <title>hystrix-go 之统计控制器实现</title>
      <link>https://maratrix.cn/post/2021/01/27/hystrix-go-metrics-read/</link>
      <pubDate>Wed, 27 Jan 2021 08:45:02 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/01/27/hystrix-go-metrics-read/</guid>
      <description>上一篇 我们分析断路器时有用到 metricExchange，但并未展开详细介绍，本篇我们主要介绍它以及实现原理。 metricExchange 主要是用来收集处理上报的所有事件，并对事件进行汇总处理，最后根据计算出来的一段时间内的错</description>
    </item>
    
    <item>
      <title>hystrix-go 之断路器实现</title>
      <link>https://maratrix.cn/post/2021/01/25/hystrix-go-circuit-read/</link>
      <pubDate>Mon, 25 Jan 2021 22:31:12 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/01/25/hystrix-go-circuit-read/</guid>
      <description>上一篇我们分析 hystrix-go 主流程时知道，对于每个 command 都有一个对应的断路器，而且在 GoC 中首先要通过 GetCircuit(name) 获取断路器对象，该方法会在断路器不存在时新建一个，并赋值给 cmd.circuit。 回顾下 command 结构体： 1type command struct { 2 // ... 3 circuit</description>
    </item>
    
    <item>
      <title>hystrix-go 之核心流程实现</title>
      <link>https://maratrix.cn/post/2021/01/24/hystrix-go-source-read/</link>
      <pubDate>Sun, 24 Jan 2021 10:36:09 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/01/24/hystrix-go-source-read/</guid>
      <description>前言 上一篇文章我们介绍了服务保护熔断器 sentinel-go 如何使用，今天介绍另外一款优秀的集限流、熔断、降级于一身的组件 hystrix-go。hystrix-go 是著名开源库 hystrix 的 Go 语言简化版本，实现了核心功能，源码实现</description>
    </item>
    
    <item>
      <title>sentinel-go 之熔断降级</title>
      <link>https://maratrix.cn/post/2021/01/20/sentinel-circuit-breaker-notes/</link>
      <pubDate>Wed, 20 Jan 2021 09:25:05 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/01/20/sentinel-circuit-breaker-notes/</guid>
      <description>在高可用设计中，除了流控外，对分布式系统调用链路中不稳定的资源(比如 RPC 服务等)进行熔断降级也是保障高可用的重要措施之一。 现代微服务架构基本都是分布式的，整个分布式系统由非常多的微服务组成。不同服务之间</description>
    </item>
    
    <item>
      <title>sentinel-go 之流量控制</title>
      <link>https://maratrix.cn/post/2021/01/19/sentinel-flow-control-notes/</link>
      <pubDate>Tue, 19 Jan 2021 08:11:23 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/01/19/sentinel-flow-control-notes/</guid>
      <description>最近考虑把工作中手头的一个鉴权服务加上限流的能力，由于接入业务方越来越多，服务的负载也越来越大，除了扩容外，服务本身也需要有限流降级的自我保护能力，避免被瞬时的流量高峰击垮，从而保障服务的高可用性。 sentinel-go</description>
    </item>
    
    <item>
      <title> Google Protobuf 编译器使用笔记</title>
      <link>https://maratrix.cn/post/2021/01/15/how-to-use-protoc-notes/</link>
      <pubDate>Fri, 15 Jan 2021 09:36:47 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/01/15/how-to-use-protoc-notes/</guid>
      <description>背景 Protobuf 是 google 开源的高性能序列化库，支持 C++、C#、Dart、Java、Go、Python、Rust 等语言，同时也是跨平台的。 Protobuf 包含序列化格式的定义、各种语言的库以及一个 IDL 编译器。正常情况下你需要定义 proto</description>
    </item>
    
    <item>
      <title>juju/ratelimit 令牌桶限流器分析</title>
      <link>https://maratrix.cn/post/2021/01/10/juju-ratelimit-read/</link>
      <pubDate>Sun, 10 Jan 2021 23:12:12 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/01/10/juju-ratelimit-read/</guid>
      <description>上一篇 我们介绍了基于漏桶算法的限流器 - uber-go/ratelimit，为了应对突发流量，它做了最大松弛量的改良。本篇文章继续介绍另外一种限流器：令牌桶（Token Bucket）。 什么是令牌桶 漏桶的</description>
    </item>
    
    <item>
      <title>uber-go/ratelimit 漏桶限流器分析</title>
      <link>https://maratrix.cn/post/2021/01/06/uber-go-ratelimit-read/</link>
      <pubDate>Wed, 06 Jan 2021 23:13:10 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2021/01/06/uber-go-ratelimit-read/</guid>
      <description>限流器是微服务中不可缺少的组件，起着保护下游服务负载过高、保证服务稳定性的作用。 什么是限流器 Web servers typically use a central in-memory key-value database, like Redis or Aerospike, for session management. A rate limiting algorithm is used to check if the user session (or IP address) has to be limited based on the information in the session cache. In case a client made too many requests within a given</description>
    </item>
    
    <item>
      <title>再见2020</title>
      <link>https://maratrix.cn/post/2020/12/31/2020-summary/</link>
      <pubDate>Thu, 31 Dec 2020 14:02:48 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/12/31/2020-summary/</guid>
      <description>第一次正式在博客公开写年终总结，其实之前也都有写，只是随手写在了某个笔记软件上，没有统一进行归档整理，更不方便查阅，然后就开始吃灰了。这次也许是个好的开始，希望以后年年坚持写下去。 2020 年确实过的很快，感</description>
    </item>
    
    <item>
      <title>[转]Go语言如何使用条件编译</title>
      <link>https://maratrix.cn/post/2020/12/17/go-cond-build/</link>
      <pubDate>Thu, 17 Dec 2020 23:00:41 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/12/17/go-cond-build/</guid>
      <description>当开发需要依赖底层平台或处理器体系特性的Go包时，提供对应的特定实现是非常有必要的。 Go没有预处理，没有宏定义系统，不可以像c语言那样使用#define来控制是否包含平台相关的特定代码。作为替代，Go</description>
    </item>
    
    <item>
      <title>Linux dd 命令使用详解</title>
      <link>https://maratrix.cn/post/2020/09/16/linux-comm-dd/</link>
      <pubDate>Wed, 16 Sep 2020 19:27:00 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/09/16/linux-comm-dd/</guid>
      <description>dd 命令介绍 Linux dd 命令用于读取、转换并输出数据。 dd 可从标准输入或文件中读取数据，根据指定的格式来转换数据，再输出到文件、设备或标准输出。 dd 命令使用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。可</description>
    </item>
    
    <item>
      <title>Go源码阅读 | channel 设计与实现</title>
      <link>https://maratrix.cn/post/2020/08/25/go-channel-source-read/</link>
      <pubDate>Tue, 25 Aug 2020 22:40:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/08/25/go-channel-source-read/</guid>
      <description>本文基于 Go1.14 源码阅读 1package runtime 2 3// 此文件实现了 Go 的 channel 4 5// 变种: 6// c.sendq 和 c.recvq 中至少一个为空，除非是 unbuffered channle 和单个 goroutine 7// 阻塞在 select 语句中同时使用发送和接受的这种情况。这时 c.sendq 和 c.recvq 的长度由 8// select 语句的大小限制。 9// 10// 对于 buffered chann</description>
    </item>
    
    <item>
      <title>Go源码阅读 | context.Context设计与实现</title>
      <link>https://maratrix.cn/post/2020/07/12/go-context-source-read/</link>
      <pubDate>Sun, 12 Jul 2020 16:55:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/07/12/go-context-source-read/</guid>
      <description>本文基于 Go1.14.2 Go 自带的 context 包设计的很巧妙，最近阅读了下源码实现，可谓是短小精悍，很值得投入时间去学习。 什么是 context Go1.7 开始引入的 context 标准库包，主要用来在协程之间传递上下文信息，包括：取消信号、超时控制、截止时间、k</description>
    </item>
    
    <item>
      <title>如何借助Go指令生成随机数</title>
      <link>https://maratrix.cn/post/2020/06/14/go-fast-random/</link>
      <pubDate>Sun, 14 Jun 2020 18:36:57 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/06/14/go-fast-random/</guid>
      <description>如何在 Go 开发中高效而又快速地生成随机数呢？相信大家首先想到的就是使用标准库自带的 math/rand 包，或者使用开源的第三方包（比如 github.com/valyala/fastrand）来实现。 Go 运行时自带了 runtime.fastrand 函数来</description>
    </item>
    
    <item>
      <title>[转]简单围观一下有趣的//go:指令</title>
      <link>https://maratrix.cn/post/2020/06/13/go-directive-syntax/</link>
      <pubDate>Sat, 13 Jun 2020 09:11:02 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/06/13/go-directive-syntax/</guid>
      <description>前言 如果你平时有翻看源码的习惯，你肯定会发现。咦，怎么有的方法上面总是写着 //go: 这类指令呢。他们到底是干嘛用的？ 今天我们一同揭开他们的面纱，我将简单给你介绍一下，它们都负责些什么。 go:linkname 1//go:linkname localname importpath.name 该指令指示编译器</description>
    </item>
    
    <item>
      <title>Go源码阅读 | sync.WaitGroup设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/25/go-sync-waitgroup-notes/</link>
      <pubDate>Sat, 25 Apr 2020 20:50:34 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/25/go-sync-waitgroup-notes/</guid>
      <description>前言 当我们的程序在运行过程中需要执行多个子任务时，我们可以利用 Go 协程并发地执行这些子任务，然后等待它们执行结束，从而缩短程序串行执行的耗费时间。Go 语言标准库自带了该组件：sync.WaitGroup</description>
    </item>
    
    <item>
      <title>Go源码阅读 | sync.Once设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/21/go-sync-once-source-notes/</link>
      <pubDate>Tue, 21 Apr 2020 11:55:18 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/21/go-sync-once-source-notes/</guid>
      <description>介绍 sync.Once 是 Go 官方自带的标准库，实现了 exactly once 的功能。通过使用 sync.Once 我们可以很方便地实现单例模式，确保对象只被初始化一次。 首先看一个 sync.Once 的 Go 官方例子，源码链接在这里： 1var once sync.Once 2onceBody := func() { 3 fmt.Println(&amp;#34;Only once&amp;#34;) 4} 5done := make(chan bool) 6for i := 0; i &amp;lt; 10; i++ {</description>
    </item>
    
    <item>
      <title>Go中如何实现禁止拷贝</title>
      <link>https://maratrix.cn/post/2020/04/20/go-nocopy-notes/</link>
      <pubDate>Mon, 20 Apr 2020 21:56:22 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/20/go-nocopy-notes/</guid>
      <description>背景 最近看 Go 标准库源码时经常遇到禁止拷贝对象的使用场景，比如当我们使用 strings.Builder 或者 sync.Pool 对象的时候会被禁止拷贝，这是如何实现的呢？ 主要有以下两种方式： 方式一：手动检查 这种需要我们在运行时通过 copyCheck 方法来检查是否发生</description>
    </item>
    
    <item>
      <title>Go源码阅读 | strings.Builder设计与实现</title>
      <link>https://maratrix.cn/post/2020/04/14/strings-builder-source-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:55:41 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/14/strings-builder-source-note/</guid>
      <description>背景之字符串拼接 在 Go 语言中，对于字符串的拼接处理有很多种方法，那么那种方法才是效率最高的呢？ 1str := []string{&amp;#34;aa&amp;#34;, &amp;#34;bb&amp;#34;, &amp;#34;cc&amp;#34;} 2ss := &amp;#34;&amp;#34; 3for _, s := range str { 4 ss += s 5} 6fmt.Println(ss) 相信大部分人都会使用+操作符或者fmt.Sprinf进行拼接，但要</description>
    </item>
    
    <item>
      <title>Go Hijack黑科技</title>
      <link>https://maratrix.cn/post/2020/04/14/go-hijack-note/</link>
      <pubDate>Tue, 14 Apr 2020 11:53:21 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/14/go-hijack-note/</guid>
      <description>最近在看Go标准库里面的rpc源码，发现了下面一段代码： 1// ServeHTTP implements an http.Handler that answers RPC requests. 2func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) { 3 if req.Method != &amp;#34;CONNECT&amp;#34; { 4 w.Header().Set(&amp;#34;Content-Type&amp;#34;, &amp;#34;text/plain; charset=utf-8&amp;#34;) 5 w.WriteHeader(http.StatusMethodNotAllowed) 6 io.WriteString(w, &amp;#34;405 must CONNECT\n&amp;#34;) 7 return 8 } 9 conn, _, err := w.(http.Hijacker).Hijack() //注意看这里 10 if err != nil { 11 log.Print(&amp;#34;rpc hijacking &amp;#34;, req.RemoteAddr, &amp;#34;: &amp;#34;, err.Error()) 12 return 13 } 14 io.WriteString(conn, &amp;#34;HTTP/1.0</description>
    </item>
    
    <item>
      <title>Nginx基于权重的轮询算法实现</title>
      <link>https://maratrix.cn/post/2020/04/14/smooth-weighted-round-robin/</link>
      <pubDate>Tue, 14 Apr 2020 11:47:28 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/04/14/smooth-weighted-round-robin/</guid>
      <description>Nginx平滑的基于权重轮询算法描述为： Algorithm is as follows: on each peer selection we increase current_weight of each eligible peer by its weight, select peer with greatest current_weight and reduce its current_weight by total number of weight points distributed among peers. 算法执行2步，选择出1个当前节点： 每个节点，用它们的当前值加上它们自己的权重。 选择当前值</description>
    </item>
    
    <item>
      <title>关于本站</title>
      <link>https://maratrix.cn/about/</link>
      <pubDate>Fri, 10 Apr 2020 00:13:27 +0000</pubDate>
      
      <guid>https://maratrix.cn/about/</guid>
      <description>不期速成，日拱一卒，浮躁时代做个专注的人！ 北漂民工 | 斜杠青年 | 知行合一 | 后续&amp;hellip;&amp;hellip; 前言 MARATRIX BLOG 就这么开通了。 2020 年，总算有个地方可以好好写点东西了。 这年头还有人写 Blog 么，我也不知道为</description>
    </item>
    
    <item>
      <title>阅读</title>
      <link>https://maratrix.cn/read/</link>
      <pubDate>Fri, 10 Apr 2020 00:13:27 +0000</pubDate>
      
      <guid>https://maratrix.cn/read/</guid>
      <description>为梦想而努力，向大佬们看齐，见贤思齐焉，这是他们的书单！ 曹大的书单 芮神的书单 潘少的书单 Go 夜读发起人书单 2020 年读书笔记</description>
    </item>
    
    <item>
      <title>Rust学习笔记007-所有权</title>
      <link>https://maratrix.cn/post/2020/02/06/007-rust-ownership-notes/</link>
      <pubDate>Thu, 06 Feb 2020 10:01:58 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/06/007-rust-ownership-notes/</guid>
      <description>什么是所有权 Rust的核心功能（之一）就是所有权，其令 Rust 无需垃圾回收即可保障内存安全。 所有运行的程序都必须管理其使用计算机内存的方式： 一些语言中具有垃圾回收机制，在程序运行时不断地寻找不再使用的内存；</description>
    </item>
    
    <item>
      <title>Rust学习笔记006-控制流</title>
      <link>https://maratrix.cn/post/2020/02/05/006-rust-control-notes/</link>
      <pubDate>Wed, 05 Feb 2020 10:00:51 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/05/006-rust-control-notes/</guid>
      <description>if表达式 Rust的if...else if ... else基本语法和大多编程语言类似，这里不再赘述。 1if条件{2//... 3}elseif条件{4//... 5}else{6//... 7}注意，这里的条件表达式不包含()括号，直接写</description>
    </item>
    
    <item>
      <title>Rust学习笔记005-函数</title>
      <link>https://maratrix.cn/post/2020/02/05/005-rust-functions-notes/</link>
      <pubDate>Wed, 05 Feb 2020 09:59:52 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/05/005-rust-functions-notes/</guid>
      <description>函数定义 使用fn关键字定义函数； 函数名使用snake_case规范命名； 函数可以定义在main函数之前或之后，Rust 不关心函数定义于何处； 1fn test_function(a: i32,b: bool)-&amp;gt; u32 {2//... 3}函数参数 函数可以定义多个参数，使用逗号,分隔</description>
    </item>
    
    <item>
      <title>Rust学习笔记004-数据类型</title>
      <link>https://maratrix.cn/post/2020/02/05/004-rust-types-notes/</link>
      <pubDate>Wed, 05 Feb 2020 09:51:09 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/05/004-rust-types-notes/</guid>
      <description>前言 Rust是静态类型语言，在编译时就必须知道所有变量的类型。 两种方式确定类型： 根据值及使用方式，编译器通常可以推断出我们想要用的类型； 当多种类型均有可能时，必须增加类型注解； 如下代码，不加类型编译会</description>
    </item>
    
    <item>
      <title>Rust学习笔记003-变量与可变性</title>
      <link>https://maratrix.cn/post/2020/02/04/003-rust-variable-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:49:40 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/04/003-rust-variable-notes/</guid>
      <description>变量声明 语法格式： 1let变量名: 变量类型=变量值;2letvar: i32 =123;有几点要注意： 以关键字let开头，类型一定跟在冒号:后面； 变量必须先声明，初始化后才能使用； 初始化 Rust中，每个变量必</description>
    </item>
    
    <item>
      <title>Rust学习笔记002-编程概念</title>
      <link>https://maratrix.cn/post/2020/02/04/002-rust-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:45:34 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/04/002-rust-notes/</guid>
      <description>标识符 Rust 中的名称被称为 “标识符”（“identifier”），它们可以是任意非空的 ASCII 字符串，不过有如下限制： 要么是： 第一个字符是字母。 其它字符是字母数字或者 _。 或者是： 第一个字符是 _。 标识符需多于一个</description>
    </item>
    
    <item>
      <title>Rust学习笔记001-初相识</title>
      <link>https://maratrix.cn/post/2020/02/04/001-rust-hello-world-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:45:20 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/04/001-rust-hello-world-notes/</guid>
      <description>Rust is a systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety. Rust是一门系统级编程语言，具有三个特点： 运行快 防止段错误 保证线程安全 C和C++是业界最流行的系统编程语言，Rust的定位与之类似，但是增加了安全性。 版本和发布策略 语</description>
    </item>
    
    <item>
      <title>Rust学习笔记000-安装</title>
      <link>https://maratrix.cn/post/2020/02/04/000-rust-install-notes/</link>
      <pubDate>Tue, 04 Feb 2020 09:40:42 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2020/02/04/000-rust-install-notes/</guid>
      <description>今天正式开始学Rust。 安装 学习一门新语言，第一件事当然是先安装。官方推荐使用rustup工具来管理安装，并提供一键安装命令，只需要在终端执行以下命令即可： 1curl --proto &amp;#39;=https&amp;#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 其实就是，先下载安装rust</description>
    </item>
    
    <item>
      <title>Go踩坑系列 | 为什么request.URL.Scheme取不到值</title>
      <link>https://maratrix.cn/post/2019/09/28/go-url-scheme-notes/</link>
      <pubDate>Sat, 28 Sep 2019 10:18:10 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/09/28/go-url-scheme-notes/</guid>
      <description>遇到的问题 最近在阅读echo框架的源码，发现context.go文件在读取请求的scheme时是单独封装了个方法。就很奇怪，go语言标准库不是自带了方法吗，干嘛不用？ 于是写了段代码来验证： 1func main() { 2 http.HandleFunc(&amp;#34;/foo&amp;#34;, func(w</description>
    </item>
    
    <item>
      <title>Go踩坑系列 | json标准库string标签你用对了么</title>
      <link>https://maratrix.cn/post/2019/09/05/go-json-string-tag-notes/</link>
      <pubDate>Thu, 05 Sep 2019 10:15:11 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/09/05/go-json-string-tag-notes/</guid>
      <description>工作中，我们会经常用到Go自带的json标准库，使用也很简单，具体用法这里不多说。 有的时候上游传过来的字段是string类型的，但是我们却想用变成int来使用。 本来用一个json:&amp;quot;,str</description>
    </item>
    
    <item>
      <title>Go服务平滑重启实践</title>
      <link>https://maratrix.cn/post/2019/07/31/go-overseer-notes/</link>
      <pubDate>Wed, 31 Jul 2019 10:12:16 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/07/31/go-overseer-notes/</guid>
      <description>为了实现Golang业务的平滑重载，研究了一下github上比较成熟的解决方案，找到如下三个库： grace endless overseer 大致看了一下源码，grace和endless是比较像的，实现步骤如下： 监听信号 收到信号时fork子</description>
    </item>
    
    <item>
      <title>go:linkname用法</title>
      <link>https://maratrix.cn/post/2019/07/12/go-linkname-syntax-notes/</link>
      <pubDate>Fri, 12 Jul 2019 10:10:42 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2019/07/12/go-linkname-syntax-notes/</guid>
      <description>什么是go:linkname 这里引用Go官方文档的解释： //go:linkname localname importpath.name The //go:linkname directive instructs the compiler to use “importpath.name” as the object file symbol name for the variable or function declared as “localname” in the source code. Because this directive can subvert the type system and package modularity, it is only enabled in</description>
    </item>
    
    <item>
      <title>创建与合并分支</title>
      <link>https://maratrix.cn/post/2014/06/27/git-branch/</link>
      <pubDate>Fri, 27 Jun 2014 21:14:30 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/06/27/git-branch/</guid>
      <description>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了</description>
    </item>
    
    <item>
      <title>Git远程仓库配置</title>
      <link>https://maratrix.cn/post/2014/06/26/git-remote-set/</link>
      <pubDate>Thu, 26 Jun 2014 21:14:30 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/06/26/git-remote-set/</guid>
      <description>首先，我们要了解Github这个神奇的网站，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。所以我们要先注册一个github帐号。 由于你的本地G</description>
    </item>
    
    <item>
      <title>添加远程仓库和从远程仓库克隆</title>
      <link>https://maratrix.cn/post/2014/06/25/git-add-remote/</link>
      <pubDate>Wed, 25 Jun 2014 21:14:30 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/06/25/git-add-remote/</guid>
      <description>现在，我们已经在本地创建了一个版本库，那么如何在Github创建了一个仓库，并且让这两个仓库进行远程同步呢？ 添加远程库 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一</description>
    </item>
    
    <item>
      <title>版本库文件的管理</title>
      <link>https://maratrix.cn/post/2014/06/24/git-version-manage/</link>
      <pubDate>Tue, 24 Jun 2014 21:14:30 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/06/24/git-version-manage/</guid>
      <description>撤销修改 现在，我们查看下one.txt文件： 1$ cat one.txt 2git is the best 3I love git 4error content 假如，当我们没提交前，又想撤销这次的修改，那该怎么办呢？这时我们可以直接手动删除修改的内容，恢复到原来的版本。此时，我们可以使用gi</description>
    </item>
    
    <item>
      <title>版本库删除文件操作</title>
      <link>https://maratrix.cn/post/2014/06/23/git-del/</link>
      <pubDate>Mon, 23 Jun 2014 21:14:30 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/06/23/git-del/</guid>
      <description>首先，我们要知道在Git中任何的操作都是一个修改，那删除文件肯定也是一个修改操作了，在工作区删除一个文件可以使用rm -f file的命令来操作： 1$ rm -f one.txt 此时，Git已经知道你删除了文件，这时候的工作区和版</description>
    </item>
    
    <item>
      <title>Git工作区和暂存区</title>
      <link>https://maratrix.cn/post/2014/06/22/git-work-stash/</link>
      <pubDate>Sun, 22 Jun 2014 21:14:30 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/06/22/git-work-stash/</guid>
      <description>首先，我们要清楚Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。下面来看几个概念： 工作区 工作区就是我们在电脑里看到的目录，比如我的learngit就是一个工作区。 版本库 在工作区中都有</description>
    </item>
    
    <item>
      <title>Git实现版本回退功能</title>
      <link>https://maratrix.cn/post/2014/06/21/git-version-reset/</link>
      <pubDate>Sat, 21 Jun 2014 21:11:27 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/06/21/git-version-reset/</guid>
      <description>现在，我们重新修改下文件并添加和提交到版本库： 1$ echo &amp;#39;再次添加新内容&amp;#39; &amp;gt;&amp;gt; readme.md 2$ git add ./readme.md 3$ git commit -m &amp;#39;更新内容&amp;#39; 像这样，我们不断的对文件进行修改，并一次一次的提交到版本库。就像我们</description>
    </item>
    
    <item>
      <title>安装分布式版本控制系统Git</title>
      <link>https://maratrix.cn/post/2014/06/20/git-install/</link>
      <pubDate>Fri, 20 Jun 2014 20:35:36 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/06/20/git-install/</guid>
      <description>Git是什么？Git是世界上最先进的分布式版本控制系统。 Git有什么特点？简单说就是：高端大气上档次！ 那么什么是版本控制系统呢？自己百度去。 很多人都知道，李纳斯创建了开源的Linux，从那时起Linu</description>
    </item>
    
    <item>
      <title>Git创建版本库和查看工作区状态</title>
      <link>https://maratrix.cn/post/2014/06/19/git-create/</link>
      <pubDate>Thu, 19 Jun 2014 20:31:25 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/06/19/git-create/</guid>
      <description>什么是版本库呢？版本库又名仓库，英文名repository，可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者</description>
    </item>
    
    <item>
      <title>PHP新增语法结构Traits</title>
      <link>https://maratrix.cn/post/2014/05/12/php-traits/</link>
      <pubDate>Mon, 12 May 2014 20:27:10 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/05/12/php-traits/</guid>
      <description>面向对象的优势在于类的复用，继承和多态都是对类进行复用，他们一个是类级别的复用，一个是方法级别的复用。其中提到继承必提组合，有什么区别呢。组合与继承都是提高代码可重用性的手段。通过总结，可以得出继承是</description>
    </item>
    
    <item>
      <title>PHP延迟静态绑定机制</title>
      <link>https://maratrix.cn/post/2014/05/11/php-static-bind/</link>
      <pubDate>Sun, 11 May 2014 20:24:12 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/05/11/php-static-bind/</guid>
      <description>自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”的类名。当进行静态方法调用时，该类名即为明确指定的那个（通</description>
    </item>
    
    <item>
      <title>[转]批判的价值</title>
      <link>https://maratrix.cn/post/2014/05/10/critical-value/</link>
      <pubDate>Sat, 10 May 2014 19:36:05 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/05/10/critical-value/</guid>
      <description>Author:YinWang 总是有人告诉我，我不应该批评一些技术，特别是不应该在一些公认的“大牛”或者流行的技术头上动土。要做出自己的“成果”，这样才可以得到大家的“尊重”。首先，你可能没有发现，被我批判得最厉害的技术和人，其</description>
    </item>
    
    <item>
      <title>开心写程序，快乐过生活</title>
      <link>https://maratrix.cn/post/2014/03/07/hello-world/</link>
      <pubDate>Fri, 07 Mar 2014 19:28:45 +0800</pubDate>
      
      <guid>https://maratrix.cn/post/2014/03/07/hello-world/</guid>
      <description>这是开通 CSDN 后的第一篇博客，呵呵，工科男就是这样，刚开始真的就是不知道该怎么去写出心中的想法和情感，也许就是碍于面子，怕被别人成为“屌丝”，希望自己可以这么坚持下去。 说实话，编程真的很枯燥，枯燥的有时会</description>
    </item>
    
    <item>
      <title>归档</title>
      <link>https://maratrix.cn/archives/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://maratrix.cn/archives/</guid>
      <description></description>
    </item>
    
    <item>
      <title>搜索</title>
      <link>https://maratrix.cn/search/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://maratrix.cn/search/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
